// Whenr Database Schema
// Group event coordination with calendar integration

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider  = "postgresql"
    url       = env("DATABASE_URL")
    directUrl = env("DIRECT_URL")
}

// User Management
model User {
    id            String    @id @default(cuid())
    email         String    @unique
    name          String?
    image         String?
    password      String? // For credentials authentication
    emailVerified DateTime? // For NextAuth.js
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt

    // Authentication
    accounts Account[]
    sessions Session[]

    // Group memberships
    groupMemberships GroupMember[]

    // Groups created by user
    createdGroups Group[] @relation("GroupCreator")

    // Calendar connections
    calendarConnections CalendarConnection[]

    // Event proposals
    eventProposals EventProposal[]

    // Event votes
    eventVotes EventVote[]

    // Chat messages
    chatMessages ChatMessage[]

    // Group activities
    groupActivities GroupActivity[]

    // Group invites
    sentInvites     GroupInvite[] @relation("GroupInviteInviter")
    receivedInvites GroupInvite[] @relation("GroupInviteUser")

    // Group read states
    groupReadStates GroupReadState[]

    // Preferences
    preferences UserPreference?

    // Event likes and search history (for algorithm)
    eventLikes    EventLike[]
    searchHistory SearchHistory[]

    // Personalized feed cache
    userFeed UserFeed?

    // Planner relations
    ownedPlans              Plan[]                     @relation("PlanOwner")
    planMemberships         PlanMember[]
    planInvites             PlanInvite[]
    ownedThreads            PlanThread[]               @relation("ThreadOwner")
    createdThreads          PlanThread[]               @relation("ThreadCreatedBy")
    searchInitiatedThreads  PlanThread[]               @relation("ThreadSearchInitiator")
    votingInitiatedThreads  PlanThread[]               @relation("ThreadVotingInitiator")
    planComments            PlanComment[]
    searchSnapshotInitiator PlanThreadSearchSnapshot[]
    planThreadItemVotes     PlanThreadItemVote[]
    selectedPlanItems       PlanThreadSelectedItem[]
    itineraryItems          PlanThreadItineraryItem[]
    planChatMessages        PlanChatMessage[]

    @@map("users")
}

// NextAuth.js Account model
model Account {
    id                String  @id @default(cuid())
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String? @db.Text
    access_token      String? @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? @db.Text
    session_state     String?

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
    @@map("accounts")
}

// NextAuth.js Session model
model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("sessions")
}

// NextAuth.js Verification Token model
model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
    @@map("verification_tokens")
}

// Group Management
model Group {
    id          String   @id @default(cuid())
    name        String
    description String?
    inviteCode  String   @unique @default(cuid())
    isPrivate   Boolean  @default(false)
    createdBy   String
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    // Icon fields
    iconType     GroupIconType @default(EMOJI)
    iconEmoji    String? // For emoji icons
    iconImageUrl String? // For uploaded images

    // Relations
    createdByUser  User             @relation("GroupCreator", fields: [createdBy], references: [id], onDelete: Cascade)
    members        GroupMember[]
    eventProposals EventProposal[]
    chatMessages   ChatMessage[]
    activities     GroupActivity[]
    invites        GroupInvite[]
    readStates     GroupReadState[]

    @@map("groups")
}

model GroupMember {
    id       String    @id @default(cuid())
    groupId  String
    userId   String
    role     GroupRole @default(MEMBER)
    joinedAt DateTime  @default(now())

    // Relations
    group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
    user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([groupId, userId])
    @@map("group_members")
}

enum GroupRole {
    ADMIN
    MEMBER
}

enum GroupIconType {
    EMOJI
    IMAGE
}

// Calendar Integration
model CalendarConnection {
    id           String           @id @default(cuid())
    userId       String
    provider     CalendarProvider
    providerId   String
    name         String? // User-friendly name for the connection
    accessToken  String           @db.Text
    refreshToken String?          @db.Text
    expiresAt    DateTime?
    isActive     Boolean          @default(true)
    lastSyncAt   DateTime? // Last time calendars were synced
    createdAt    DateTime         @default(now())
    updatedAt    DateTime         @updatedAt

    // Relations
    user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
    calendars SharedCalendar[]

    @@unique([userId, provider, providerId])
    @@map("calendar_connections")
}

enum CalendarProvider {
    GOOGLE
    MICROSOFT
    APPLE
}

model SharedCalendar {
    id                 String     @id @default(cuid())
    connectionId       String
    providerCalendarId String
    name               String
    color              String? // Calendar color for UI display
    isShared           Boolean    @default(false)
    shareLevel         ShareLevel @default(BUSY_ONLY)
    createdAt          DateTime   @default(now())
    updatedAt          DateTime   @updatedAt

    // Relations
    connection CalendarConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

    @@unique([connectionId, providerCalendarId])
    @@map("shared_calendars")
}

enum ShareLevel {
    BUSY_ONLY
    DETAILED
    FULL_ACCESS
}

// Event Discovery & Caching
model CachedEvent {
    id          String      @id @default(cuid())
    source      EventSource
    sourceId    String // External API event ID
    title       String
    description String?     @db.Text
    startDate   DateTime
    endDate     DateTime?
    location    String?
    venue       String?
    imageUrl    String?
    sourceUrl   String
    price       String?
    category    String?
    tags        String[] // Array of tags/categories
    isActive    Boolean     @default(true)
    lastFetched DateTime    @default(now())
    createdAt   DateTime    @default(now())
    updatedAt   DateTime    @updatedAt

    // Relations
    proposals EventProposal[]

    @@unique([source, sourceId])
    @@map("cached_events")
}

// Event Management
model EventProposal {
    id            String         @id @default(cuid())
    groupId       String
    proposerId    String
    cachedEventId String? // Reference to cached event if from external API
    title         String
    description   String?
    startDate     DateTime
    endDate       DateTime
    location      String?
    source        EventSource
    sourceId      String? // ID from external API (Eventbrite, etc.) - deprecated, use cachedEventId
    sourceUrl     String? // URL to original event - deprecated, use cachedEventId
    status        ProposalStatus @default(PENDING)
    createdAt     DateTime       @default(now())
    updatedAt     DateTime       @updatedAt

    // Relations
    group        Group         @relation(fields: [groupId], references: [id], onDelete: Cascade)
    proposer     User          @relation(fields: [proposerId], references: [id], onDelete: Cascade)
    cachedEvent  CachedEvent?  @relation(fields: [cachedEventId], references: [id], onDelete: SetNull)
    votes        EventVote[]
    chatMessages ChatMessage[]

    @@map("event_proposals")
}

enum EventSource {
    MANUAL
    EVENTBRITE
    TICKETMASTER
    MEETUP
}

enum ProposalStatus {
    PENDING
    APPROVED
    REJECTED
    CANCELLED
}

model EventVote {
    id         String   @id @default(cuid())
    proposalId String
    userId     String
    vote       VoteType
    createdAt  DateTime @default(now())
    updatedAt  DateTime @updatedAt

    // Relations
    proposal EventProposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
    user     User          @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([proposalId, userId])
    @@map("event_votes")
}

enum VoteType {
    YES
    NO
    MAYBE
}

// Chat System
model ChatMessage {
    id            String      @id @default(cuid())
    /// Optional Ably message id for idempotency across webhook retries
    ablyMessageId String?     @unique
    groupId       String?
    proposalId    String?
    userId        String
    content       String      @db.Text
    messageType   MessageType @default(TEXT)
    createdAt     DateTime    @default(now())
    updatedAt     DateTime    @updatedAt

    // Relations
    group    Group?         @relation(fields: [groupId], references: [id], onDelete: Cascade)
    proposal EventProposal? @relation(fields: [proposalId], references: [id], onDelete: Cascade)
    user     User           @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("chat_messages")
}

enum MessageType {
    TEXT
    IMAGE
    FILE
    SYSTEM
}

// Group Activity Feed
model GroupActivity {
    id           String       @id @default(cuid())
    groupId      String
    userId       String?
    activityType ActivityType
    title        String
    description  String?      @db.Text
    metadata     Json? // Store additional data like event details, member info, etc.
    createdAt    DateTime     @default(now())

    // Relations
    group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
    user  User? @relation(fields: [userId], references: [id], onDelete: SetNull)

    @@map("group_activities")
}

enum ActivityType {
    GROUP_CREATED
    MEMBER_JOINED
    MEMBER_LEFT
    EVENT_PROPOSED
    EVENT_APPROVED
    EVENT_CANCELLED
    GROUP_UPDATED
}

// Group Invites
model GroupInvite {
    id           String    @id @default(cuid())
    groupId      String
    invitedBy    String // User ID who created the invite
    invitedEmail String // Email address of the person being invited
    inviteCode   String    @unique @default(cuid())
    expiresAt    DateTime
    isUsed       Boolean   @default(false)
    usedAt       DateTime?
    usedBy       String? // User ID who used the invite
    createdAt    DateTime  @default(now())

    // Relations
    group   Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
    inviter User  @relation("GroupInviteInviter", fields: [invitedBy], references: [id], onDelete: Cascade)
    user    User? @relation("GroupInviteUser", fields: [usedBy], references: [id], onDelete: SetNull)

    @@map("group_invites")
}

// Group Read State (tracks when user last read each group)
model GroupReadState {
    id                String   @id @default(cuid())
    userId            String
    groupId           String
    lastReadAt        DateTime @default(now())
    lastReadMessageId String? // Optional: specific message ID they read up to
    updatedAt         DateTime @updatedAt

    // Relations
    user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
    group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

    // Ensure one read state per user per group
    @@unique([userId, groupId])
    @@index([userId]) // Fast lookup of user's read states
    @@index([groupId]) // Fast lookup by group
    @@map("group_read_states")
}

// User Preferences
model UserPreference {
    id                 String          @id @default(cuid())
    userId             String          @unique
    theme              ThemePreference @default(SYSTEM)
    emailNotifications Boolean         @default(true)
    eventReminders     Boolean         @default(true)
    weeklyDigest       Boolean         @default(false)
    timezone           String?

    // Home/default location for feed generation
    defaultLat  Float? // Home latitude
    defaultLon  Float? // Home longitude
    defaultCity String? // Home city name

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("user_preferences")
}

enum ThemePreference {
    LIGHT
    DARK
    SYSTEM
}

// Planner Enums
enum PlanRole {
    OWNER
    EDITOR
    VIEWER
}

enum EventPlanSource {
    TICKETMASTER
    WEBCRAWLER
    MANUAL
}

enum EventPlanStatus {
    SCHEDULED
    CANCELLED
    RAIN_DELAY
    POSTPONED
    RESCHEDULED
    UNKNOWN
}

enum PlanThreadStatus {
    OPEN
    IN_PROGRESS
    DONE
}

enum SearchProvider {
    SERPAPI
    GOOGLE_CSE
    OPENAI_TOOLS
    PERPLEXITY
    CUSTOM
}

enum SearchStatus {
    PENDING
    SUCCESS
    ERROR
    PARTIAL
}

enum VotingStatus {
    NOT_READY
    READY
    IN_PROGRESS
    COMPLETE
}

enum ConfirmationStatus {
    PENDING
    CONFIRMED
    CANCELLED
}

enum ThreadItemVoteType {
    SELECT
    REMOVE
}

enum ItineraryItemType {
    FROM_SEARCH
    MANUAL
    HOTEL
    RESTAURANT
    ACTIVITY
    TRANSPORTATION
}

enum ItineraryStatus {
    PLANNED
    BOOKED
    CONFIRMED
    CANCELLED
}

enum PlanChatSenderType {
    USER
    AI
}

// Event Likes (for user preferences and algorithm)
model EventLike {
    id          String           @id @default(cuid())
    userId      String
    eventSource LikedEventSource
    sourceId    String // External event ID (from Ticketmaster API or wc_events table)
    eventData   Json // Snapshot of event data (title, date, location, imageUrl, category, etc.)
    createdAt   DateTime         @default(now())

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    // Indexes for fast lookups
    @@unique([userId, eventSource, sourceId]) // Prevent duplicate likes
    @@index([userId]) // Fast lookup of user's likes
    @@index([eventSource, sourceId]) // Fast lookup by event
    @@index([createdAt]) // For sorting by recent likes
    @@map("event_likes")
}

enum LikedEventSource {
    TICKETMASTER // Event from Ticketmaster API
    WEBCRAWLER // Event from wc_events table
}

// Search History (for user preferences and algorithm - 45-day retention)
model SearchHistory {
    id          String   @id @default(cuid())
    userId      String
    query       String? // Text search query (nullable for location-only searches)
    filters     Json // JSON object storing all search parameters (near, radiusMiles, startMin, startMax, category, priceMin, priceMax, sort)
    resultCount Int      @default(0) // Number of results returned
    createdAt   DateTime @default(now())

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    // Indexes for fast lookups
    @@index([userId, createdAt]) // Fast lookup of user's search history sorted by date
    @@index([createdAt]) // For cleanup queries (deleting old searches > 45 days)
    @@map("search_history")
}

// User Feed Cache (pre-computed personalized feeds)
model UserFeed {
    id         String   @id @default(cuid())
    userId     String   @unique
    feedData   Json // Pre-computed feed sections (JSON structure defined by algorithm)
    computedAt DateTime @default(now())
    expiresAt  DateTime // When this feed becomes stale (typically 4 hours)
    version    Int      @default(1) // Feed algorithm version (for A/B testing)

    // Context used for computation (for smart cache invalidation)
    locationLat  Float?
    locationLon  Float?
    locationCity String?

    // Performance tracking
    computationTimeMs Int? // How long it took to compute this feed
    eventCount        Int? // Total events in feed

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    // Indexes
    @@index([expiresAt]) // For cleanup of expired feeds
    @@index([userId]) // Fast user lookup
    @@map("user_feeds")
}

// ============================================================================
// PLANNER MODELS
// ============================================================================

// Core Plan
model Plan {
    id               String          @id @default(cuid())
    ownerId          String
    title            String
    description      String?
    // Event snapshot (stable even if upstream changes)
    eventSource      EventPlanSource
    eventSourceId    String? // External id (Ticketmaster ID or wc_events.id string)
    eventSourceUrl   String? // Original source URL
    eventTitle       String
    eventDescription String?         @db.Text
    eventStatus      EventPlanStatus @default(SCHEDULED)
    venueName        String?
    venueAddress     String?
    venueCity        String?
    venueRegion      String?
    venueCountry     String?
    venueLat         Float?
    venueLon         Float?
    startAt          DateTime?
    endAt            DateTime?
    createdAt        DateTime        @default(now())
    updatedAt        DateTime        @updatedAt

    // Relations
    owner        User              @relation("PlanOwner", fields: [ownerId], references: [id], onDelete: Cascade)
    members      PlanMember[]
    invites      PlanInvite[]
    threads      PlanThread[]
    chatMessages PlanChatMessage[]

    @@index([ownerId])
    @@index([eventSource, eventSourceId])
    @@map("plans")
}

model PlanMember {
    id        String   @id @default(cuid())
    planId    String
    userId    String
    role      PlanRole @default(VIEWER)
    createdAt DateTime @default(now())

    plan Plan @relation(fields: [planId], references: [id], onDelete: Cascade)
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([planId, userId])
    @@index([userId])
    @@map("plan_members")
}

model PlanInvite {
    id        String    @id @default(cuid())
    planId    String
    email     String
    role      PlanRole  @default(EDITOR)
    code      String    @unique
    expiresAt DateTime
    isUsed    Boolean   @default(false)
    usedAt    DateTime?
    usedBy    String?
    createdAt DateTime  @default(now())

    plan       Plan  @relation(fields: [planId], references: [id], onDelete: Cascade)
    usedByUser User? @relation(fields: [usedBy], references: [id], onDelete: SetNull)

    @@index([planId])
    @@index([email])
    @@map("plan_invites")
}

// Plan-level AI chat (user chats with AI to help set up threads)
model PlanChatMessage {
    id         String             @id @default(cuid())
    planId     String
    userId     String? // null if sender is AI
    senderType PlanChatSenderType
    content    String             @db.Text
    metadata   Json? // Store AI intent/thread suggestions, etc.
    createdAt  DateTime           @default(now())

    plan Plan  @relation(fields: [planId], references: [id], onDelete: Cascade)
    user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([planId, createdAt])
    @@index([userId])
    @@map("plan_chat_messages")
}

// Threads (legs) with optional nesting
model PlanThread {
    id             String           @id @default(cuid())
    planId         String
    parentThreadId String?
    title          String
    description    String?
    position       Int              @default(0)
    status         PlanThreadStatus @default(OPEN)

    // Ownership + workflow
    threadOwnerId     String
    searchStatus      SearchStatus @default(PENDING)
    votingStatus      VotingStatus @default(NOT_READY)
    searchInitiatedBy String?
    votingInitiatedBy String?
    searchInitiatedAt DateTime?
    votingInitiatedAt DateTime?

    createdBy String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    plan            Plan         @relation(fields: [planId], references: [id], onDelete: Cascade)
    parent          PlanThread?  @relation("ThreadHierarchy", fields: [parentThreadId], references: [id], onDelete: Cascade)
    children        PlanThread[] @relation("ThreadHierarchy")
    owner           User         @relation("ThreadOwner", fields: [threadOwnerId], references: [id], onDelete: Cascade)
    createdByUser   User         @relation("ThreadCreatedBy", fields: [createdBy], references: [id], onDelete: Cascade)
    searchInitiator User?        @relation("ThreadSearchInitiator", fields: [searchInitiatedBy], references: [id], onDelete: SetNull)
    votingInitiator User?        @relation("ThreadVotingInitiator", fields: [votingInitiatedBy], references: [id], onDelete: SetNull)

    comments        PlanComment[]
    searchSnapshots PlanThreadSearchSnapshot[]
    searchItems     PlanThreadSearchItem[]
    selectedItem    PlanThreadSelectedItem?
    itineraryItems  PlanThreadItineraryItem[]

    @@index([planId])
    @@index([parentThreadId])
    @@index([position])
    @@map("plan_threads")
}

model PlanComment {
    id            String   @id @default(cuid())
    /// Optional Ably message id for idempotency across webhook retries
    ablyMessageId String?  @unique
    threadId      String
    userId        String
    content       String   @db.Text
    createdAt     DateTime @default(now())

    thread PlanThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
    user   User       @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([threadId])
    @@index([userId])
    @@map("plan_comments")
}

// AI/Web search snapshots per thread (immutable snapshots for audit/refresh)
model PlanThreadSearchSnapshot {
    id           String         @id @default(cuid())
    threadId     String
    queryText    String
    provider     SearchProvider
    status       SearchStatus   @default(PENDING)
    resultsJson  Json
    metaJson     Json?
    errorMessage String?
    dedupeKey    String?        @unique
    initiatedBy  String
    createdAt    DateTime       @default(now())
    refreshedAt  DateTime?
    expiresAt    DateTime?

    thread    PlanThread             @relation(fields: [threadId], references: [id], onDelete: Cascade)
    initiator User                   @relation(fields: [initiatedBy], references: [id], onDelete: Cascade)
    items     PlanThreadSearchItem[]

    @@index([threadId])
    @@index([provider, createdAt])
    @@map("plan_thread_search_snapshots")
}

// Normalized items derived from snapshot for finer UI/analytics
model PlanThreadSearchItem {
    id         String   @id @default(cuid())
    snapshotId String
    threadId   String
    url        String?
    title      String?
    snippet    String?
    sourceName String?
    sourceIcon String?
    rank       Int?
    score      Float?
    price      Decimal?
    currency   String?
    location   String?
    rawJson    Json
    createdAt  DateTime @default(now())

    snapshot   PlanThreadSearchSnapshot @relation(fields: [snapshotId], references: [id], onDelete: Cascade)
    thread     PlanThread               @relation(fields: [threadId], references: [id], onDelete: Cascade)
    votes      PlanThreadItemVote[]
    selectedBy PlanThreadSelectedItem?

    @@index([snapshotId])
    @@index([threadId])
    @@index([url])
    @@map("plan_thread_search_items")
}

model PlanThreadItemVote {
    id                 String             @id @default(cuid())
    threadSearchItemId String
    userId             String
    voteType           ThreadItemVoteType @default(SELECT)
    createdAt          DateTime           @default(now())

    item PlanThreadSearchItem @relation(fields: [threadSearchItemId], references: [id], onDelete: Cascade)
    user User                 @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([threadSearchItemId, userId])
    @@index([userId])
    @@map("plan_thread_item_votes")
}

// One selected item per thread (can be from search or manually provided)
model PlanThreadSelectedItem {
    id                 String             @id @default(cuid())
    threadId           String             @unique
    threadSearchItemId String?            @unique // Unique so each search item can only be selected once
    selectedBy         String
    isGroupDecision    Boolean            @default(false)
    confirmationStatus ConfirmationStatus @default(PENDING)
    votingCompletedAt  DateTime?
    notes              String?
    customData         Json?
    createdAt          DateTime           @default(now())
    updatedAt          DateTime           @updatedAt

    thread   PlanThread            @relation(fields: [threadId], references: [id], onDelete: Cascade)
    item     PlanThreadSearchItem? @relation(fields: [threadSearchItemId], references: [id], onDelete: SetNull)
    selector User                  @relation(fields: [selectedBy], references: [id], onDelete: Cascade)

    @@index([selectedBy])
    @@map("plan_thread_selected_items")
}

// Optional: Multiple confirmed itinerary items per thread (use this if you want checklist functionality)
model PlanThreadItineraryItem {
    id              String            @id @default(cuid())
    threadId        String
    itemType        ItineraryItemType @default(FROM_SEARCH)
    title           String
    description     String?
    url             String?
    phone           String?
    address         String?
    price           Decimal?
    priceCurrency   String?
    reservationInfo Json?
    status          ItineraryStatus   @default(PLANNED)
    addedBy         String
    position        Int               @default(0)
    createdAt       DateTime          @default(now())
    updatedAt       DateTime          @updatedAt

    thread      PlanThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
    addedByUser User       @relation(fields: [addedBy], references: [id], onDelete: Cascade)

    @@index([threadId])
    @@index([addedBy])
    @@index([position])
    @@map("plan_thread_itinerary_items")
}

// Beta Signup Management
model BetaSignup {
    id        String   @id @default(cuid())
    email     String   @unique
    ipAddress String?
    userAgent String?
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("beta_signups")
}

// ============================================================================
// WEB CRAWLER TABLES (Managed externally - DO NOT DROP)
// ============================================================================
// These tables are managed by the web crawler service and contain production data.
// They are defined here so Prisma is aware of them and won't try to drop them.

model WebCrawlerVenue {
    id            BigInt                                    @id @default(autoincrement())
    name          String?
    streetAddress String?                                   @map("street_address")
    locality      String?
    region        String?
    postalCode    String?                                   @map("postal_code")
    country       String?
    lat           Float?
    lon           Float?
    createdAt     DateTime                                  @default(now()) @map("created_at")
    location      Unsupported("gis.geography(Point,4326)")? // PostGIS geography type
    searchVector  Unsupported("tsvector")?                  @map("search_vector")

    // Relations
    events WebCrawlerEvent[]

    // Indexes
    @@unique([name, locality, region, postalCode, country])
    @@index([location], type: Gist)
    @@index([searchVector], type: Gin)
    @@index([lat, lon])
    @@map("wc_venues")
}

model WebCrawlerEvent {
    id           String                   @id
    source       String
    sourceId     String?                  @map("source_id")
    sourceUrl    String                   @unique @map("source_url")
    title        String
    description  String?
    startAt      DateTime?                @map("start_at")
    endAt        DateTime?                @map("end_at")
    timezone     String?
    status       String?
    venueId      BigInt?                  @map("venue_id")
    images       Json?
    categories   String[]
    performers   Json?
    createdAt    DateTime                 @default(now()) @map("created_at")
    updatedAt    DateTime                 @default(now()) @map("updated_at")
    searchVector Unsupported("tsvector")? @map("search_vector")

    // Relations
    venue  WebCrawlerVenue?  @relation(fields: [venueId], references: [id], onDelete: SetNull)
    offers WebCrawlerOffer[]

    // Indexes
    @@index([sourceUrl])
    @@index([startAt])
    @@index([venueId])
    @@index([searchVector], type: Gin)
    @@map("wc_events")
}

model WebCrawlerOffer {
    id           BigInt    @id @default(autoincrement())
    eventId      String?   @map("event_id")
    url          String?
    price        Decimal?  @db.Decimal
    currency     String?
    availability String?
    validFrom    DateTime? @map("valid_from")
    checkedAt    DateTime? @default(now()) @map("checked_at")

    // Relations
    event WebCrawlerEvent? @relation(fields: [eventId], references: [id], onDelete: Cascade)

    // Indexes
    @@index([eventId])
    @@map("wc_offers")
}

model WebCrawlerPage {
    url          String    @id
    discoveredAt DateTime  @default(now()) @map("discovered_at")
    lastChecked  DateTime? @map("last_checked")
    etag         String?
    lastModified DateTime? @map("last_modified")
    status       Int?
    country      String?
    lat          Float?
    lon          Float?

    // Indexes
    @@index([lastChecked])
    @@map("wc_pages")
}

model WebCrawlerSitemapPart {
    loc       String    @id
    lastmod   DateTime?
    fetchedAt DateTime? @map("fetched_at")

    @@map("wc_sitemap_parts")
}
