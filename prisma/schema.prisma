// Whenr Database Schema
// Group event coordination with calendar integration

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider  = "postgresql"
    url       = env("DATABASE_URL")
    directUrl = env("DIRECT_URL")
}

// User Management
model User {
    id            String    @id @default(cuid())
    email         String    @unique
    name          String?
    image         String?
    password      String? // For credentials authentication
    emailVerified DateTime? // For NextAuth.js
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt

    // Authentication
    accounts Account[]
    sessions Session[]

    // Group memberships
    groupMemberships GroupMember[]

    // Groups created by user
    createdGroups Group[] @relation("GroupCreator")

    // Calendar connections
    calendarConnections CalendarConnection[]

    // Event proposals
    eventProposals EventProposal[]

    // Event votes
    eventVotes EventVote[]

    // Chat messages
    chatMessages ChatMessage[]

    // Group activities
    groupActivities GroupActivity[]

    // Group invites
    sentInvites     GroupInvite[] @relation("GroupInviteInviter")
    receivedInvites GroupInvite[] @relation("GroupInviteUser")

    // Preferences
    preferences UserPreference?

    // Event likes and search history (for algorithm)
    eventLikes    EventLike[]
    searchHistory SearchHistory[]

    // Personalized feed cache
    userFeed UserFeed?

    @@map("users")
}

// NextAuth.js Account model
model Account {
    id                String  @id @default(cuid())
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String? @db.Text
    access_token      String? @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? @db.Text
    session_state     String?

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
    @@map("accounts")
}

// NextAuth.js Session model
model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("sessions")
}

// NextAuth.js Verification Token model
model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
    @@map("verification_tokens")
}

// Group Management
model Group {
    id          String   @id @default(cuid())
    name        String
    description String?
    inviteCode  String   @unique @default(cuid())
    isPrivate   Boolean  @default(false)
    createdBy   String
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    // Icon fields
    iconType     GroupIconType @default(EMOJI)
    iconEmoji    String? // For emoji icons
    iconImageUrl String? // For uploaded images

    // Relations
    createdByUser  User            @relation("GroupCreator", fields: [createdBy], references: [id], onDelete: Cascade)
    members        GroupMember[]
    eventProposals EventProposal[]
    chatMessages   ChatMessage[]
    activities     GroupActivity[]
    invites        GroupInvite[]

    @@map("groups")
}

model GroupMember {
    id       String    @id @default(cuid())
    groupId  String
    userId   String
    role     GroupRole @default(MEMBER)
    joinedAt DateTime  @default(now())

    // Relations
    group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
    user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([groupId, userId])
    @@map("group_members")
}

enum GroupRole {
    ADMIN
    MEMBER
}

enum GroupIconType {
    EMOJI
    IMAGE
}

// Calendar Integration
model CalendarConnection {
    id           String           @id @default(cuid())
    userId       String
    provider     CalendarProvider
    providerId   String
    name         String? // User-friendly name for the connection
    accessToken  String           @db.Text
    refreshToken String?          @db.Text
    expiresAt    DateTime?
    isActive     Boolean          @default(true)
    lastSyncAt   DateTime? // Last time calendars were synced
    createdAt    DateTime         @default(now())
    updatedAt    DateTime         @updatedAt

    // Relations
    user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
    calendars SharedCalendar[]

    @@unique([userId, provider, providerId])
    @@map("calendar_connections")
}

enum CalendarProvider {
    GOOGLE
    MICROSOFT
    APPLE
}

model SharedCalendar {
    id                 String     @id @default(cuid())
    connectionId       String
    providerCalendarId String
    name               String
    color              String? // Calendar color for UI display
    isShared           Boolean    @default(false)
    shareLevel         ShareLevel @default(BUSY_ONLY)
    createdAt          DateTime   @default(now())
    updatedAt          DateTime   @updatedAt

    // Relations
    connection CalendarConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

    @@unique([connectionId, providerCalendarId])
    @@map("shared_calendars")
}

enum ShareLevel {
    BUSY_ONLY
    DETAILED
    FULL_ACCESS
}

// Event Discovery & Caching
model CachedEvent {
    id          String      @id @default(cuid())
    source      EventSource
    sourceId    String // External API event ID
    title       String
    description String?     @db.Text
    startDate   DateTime
    endDate     DateTime?
    location    String?
    venue       String?
    imageUrl    String?
    sourceUrl   String
    price       String?
    category    String?
    tags        String[] // Array of tags/categories
    isActive    Boolean     @default(true)
    lastFetched DateTime    @default(now())
    createdAt   DateTime    @default(now())
    updatedAt   DateTime    @updatedAt

    // Relations
    proposals EventProposal[]

    @@unique([source, sourceId])
    @@map("cached_events")
}

// Event Management
model EventProposal {
    id            String         @id @default(cuid())
    groupId       String
    proposerId    String
    cachedEventId String? // Reference to cached event if from external API
    title         String
    description   String?
    startDate     DateTime
    endDate       DateTime
    location      String?
    source        EventSource
    sourceId      String? // ID from external API (Eventbrite, etc.) - deprecated, use cachedEventId
    sourceUrl     String? // URL to original event - deprecated, use cachedEventId
    status        ProposalStatus @default(PENDING)
    createdAt     DateTime       @default(now())
    updatedAt     DateTime       @updatedAt

    // Relations
    group        Group         @relation(fields: [groupId], references: [id], onDelete: Cascade)
    proposer     User          @relation(fields: [proposerId], references: [id], onDelete: Cascade)
    cachedEvent  CachedEvent?  @relation(fields: [cachedEventId], references: [id], onDelete: SetNull)
    votes        EventVote[]
    chatMessages ChatMessage[]

    @@map("event_proposals")
}

enum EventSource {
    MANUAL
    EVENTBRITE
    TICKETMASTER
    MEETUP
}

enum ProposalStatus {
    PENDING
    APPROVED
    REJECTED
    CANCELLED
}

model EventVote {
    id         String   @id @default(cuid())
    proposalId String
    userId     String
    vote       VoteType
    createdAt  DateTime @default(now())
    updatedAt  DateTime @updatedAt

    // Relations
    proposal EventProposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
    user     User          @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([proposalId, userId])
    @@map("event_votes")
}

enum VoteType {
    YES
    NO
    MAYBE
}

// Chat System
model ChatMessage {
    id            String      @id @default(cuid())
    /// Optional Ably message id for idempotency across webhook retries
    ablyMessageId String?     @unique
    groupId       String?
    proposalId    String?
    userId        String
    content       String      @db.Text
    messageType   MessageType @default(TEXT)
    createdAt     DateTime    @default(now())
    updatedAt     DateTime    @updatedAt

    // Relations
    group    Group?         @relation(fields: [groupId], references: [id], onDelete: Cascade)
    proposal EventProposal? @relation(fields: [proposalId], references: [id], onDelete: Cascade)
    user     User           @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("chat_messages")
}

enum MessageType {
    TEXT
    IMAGE
    FILE
    SYSTEM
}

// Group Activity Feed
model GroupActivity {
    id           String       @id @default(cuid())
    groupId      String
    userId       String?
    activityType ActivityType
    title        String
    description  String?      @db.Text
    metadata     Json? // Store additional data like event details, member info, etc.
    createdAt    DateTime     @default(now())

    // Relations
    group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
    user  User? @relation(fields: [userId], references: [id], onDelete: SetNull)

    @@map("group_activities")
}

enum ActivityType {
    GROUP_CREATED
    MEMBER_JOINED
    MEMBER_LEFT
    EVENT_PROPOSED
    EVENT_APPROVED
    EVENT_CANCELLED
    GROUP_UPDATED
}

// Group Invites
model GroupInvite {
    id           String    @id @default(cuid())
    groupId      String
    invitedBy    String // User ID who created the invite
    invitedEmail String // Email address of the person being invited
    inviteCode   String    @unique @default(cuid())
    expiresAt    DateTime
    isUsed       Boolean   @default(false)
    usedAt       DateTime?
    usedBy       String? // User ID who used the invite
    createdAt    DateTime  @default(now())

    // Relations
    group   Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
    inviter User  @relation("GroupInviteInviter", fields: [invitedBy], references: [id], onDelete: Cascade)
    user    User? @relation("GroupInviteUser", fields: [usedBy], references: [id], onDelete: SetNull)

    @@map("group_invites")
}

// User Preferences
model UserPreference {
    id                 String          @id @default(cuid())
    userId             String          @unique
    theme              ThemePreference @default(SYSTEM)
    emailNotifications Boolean         @default(true)
    eventReminders     Boolean         @default(true)
    weeklyDigest       Boolean         @default(false)
    timezone           String?
    createdAt          DateTime        @default(now())
    updatedAt          DateTime        @updatedAt

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("user_preferences")
}

enum ThemePreference {
    LIGHT
    DARK
    SYSTEM
}

// Event Likes (for user preferences and algorithm)
model EventLike {
    id          String           @id @default(cuid())
    userId      String
    eventSource LikedEventSource
    sourceId    String // External event ID (from Ticketmaster API or wc_events table)
    eventData   Json // Snapshot of event data (title, date, location, imageUrl, category, etc.)
    createdAt   DateTime         @default(now())

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    // Indexes for fast lookups
    @@unique([userId, eventSource, sourceId]) // Prevent duplicate likes
    @@index([userId]) // Fast lookup of user's likes
    @@index([eventSource, sourceId]) // Fast lookup by event
    @@index([createdAt]) // For sorting by recent likes
    @@map("event_likes")
}

enum LikedEventSource {
    TICKETMASTER // Event from Ticketmaster API
    WEBCRAWLER // Event from wc_events table
}

// Search History (for user preferences and algorithm - 45-day retention)
model SearchHistory {
    id          String   @id @default(cuid())
    userId      String
    query       String? // Text search query (nullable for location-only searches)
    filters     Json // JSON object storing all search parameters (near, radiusMiles, startMin, startMax, category, priceMin, priceMax, sort)
    resultCount Int      @default(0) // Number of results returned
    createdAt   DateTime @default(now())

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    // Indexes for fast lookups
    @@index([userId, createdAt]) // Fast lookup of user's search history sorted by date
    @@index([createdAt]) // For cleanup queries (deleting old searches > 45 days)
    @@map("search_history")
}

// User Feed Cache (pre-computed personalized feeds)
model UserFeed {
    id         String   @id @default(cuid())
    userId     String   @unique
    feedData   Json // Pre-computed feed sections (JSON structure defined by algorithm)
    computedAt DateTime @default(now())
    expiresAt  DateTime // When this feed becomes stale (typically 4 hours)
    version    Int      @default(1) // Feed algorithm version (for A/B testing)

    // Context used for computation (for smart cache invalidation)
    locationLat  Float?
    locationLon  Float?
    locationCity String?

    // Performance tracking
    computationTimeMs Int? // How long it took to compute this feed
    eventCount        Int? // Total events in feed

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    // Indexes
    @@index([expiresAt]) // For cleanup of expired feeds
    @@index([userId]) // Fast user lookup
    @@map("user_feeds")
}

// Beta Signup Management
model BetaSignup {
    id        String   @id @default(cuid())
    email     String   @unique
    ipAddress String?
    userAgent String?
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("beta_signups")
}

// ============================================================================
// WEB CRAWLER TABLES (Managed externally - DO NOT DROP)
// ============================================================================
// These tables are managed by the web crawler service and contain production data.
// They are defined here so Prisma is aware of them and won't try to drop them.

model WebCrawlerVenue {
    id            BigInt                                @id @default(autoincrement())
    name          String?
    streetAddress String?                               @map("street_address")
    locality      String?
    region        String?
    postalCode    String?                               @map("postal_code")
    country       String?
    lat           Float?
    lon           Float?
    createdAt     DateTime                              @default(now()) @map("created_at")
    location      Unsupported("geography(Point,4326)")? // PostGIS geography type
    searchVector  Unsupported("tsvector")?              @map("search_vector")

    // Relations
    events WebCrawlerEvent[]

    // Indexes
    @@unique([name, locality, region, postalCode, country])
    @@index([location], type: Gist)
    @@index([searchVector], type: Gin)
    @@index([lat, lon])
    @@map("wc_venues")
}

model WebCrawlerEvent {
    id           String                   @id
    source       String
    sourceId     String?                  @map("source_id")
    sourceUrl    String                   @unique @map("source_url")
    title        String
    description  String?
    startAt      DateTime?                @map("start_at")
    endAt        DateTime?                @map("end_at")
    timezone     String?
    status       String?
    venueId      BigInt?                  @map("venue_id")
    images       Json?
    categories   String[]
    performers   Json?
    createdAt    DateTime                 @default(now()) @map("created_at")
    updatedAt    DateTime                 @default(now()) @map("updated_at")
    searchVector Unsupported("tsvector")? @map("search_vector")

    // Relations
    venue  WebCrawlerVenue?  @relation(fields: [venueId], references: [id], onDelete: SetNull)
    offers WebCrawlerOffer[]

    // Indexes
    @@index([sourceUrl])
    @@index([startAt])
    @@index([venueId])
    @@index([searchVector], type: Gin)
    @@map("wc_events")
}

model WebCrawlerOffer {
    id           BigInt    @id @default(autoincrement())
    eventId      String?   @map("event_id")
    url          String?
    price        Decimal?  @db.Decimal
    currency     String?
    availability String?
    validFrom    DateTime? @map("valid_from")
    checkedAt    DateTime? @default(now()) @map("checked_at")

    // Relations
    event WebCrawlerEvent? @relation(fields: [eventId], references: [id], onDelete: Cascade)

    // Indexes
    @@index([eventId])
    @@map("wc_offers")
}

model WebCrawlerPage {
    url          String    @id
    discoveredAt DateTime  @default(now()) @map("discovered_at")
    lastChecked  DateTime? @map("last_checked")
    etag         String?
    lastModified DateTime? @map("last_modified")
    status       Int?
    country      String?
    lat          Float?
    lon          Float?

    // Indexes
    @@index([lastChecked])
    @@map("wc_pages")
}

model WebCrawlerSitemapPart {
    loc       String    @id
    lastmod   DateTime?
    fetchedAt DateTime? @map("fetched_at")

    @@map("wc_sitemap_parts")
}
